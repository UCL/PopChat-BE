package uk.ac.ucl.rits.popchat;

import java.security.Principal;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import me.atrox.haikunator.Haikunator;
import uk.ac.ucl.rits.popchat.game.SongGameQuestion;
import uk.ac.ucl.rits.popchat.game.SongGameQuestionOption;
import uk.ac.ucl.rits.popchat.game.SongGameResponse;
import uk.ac.ucl.rits.popchat.game.SongGameResponseRepository;
import uk.ac.ucl.rits.popchat.messages.BatchUserSpecification;
import uk.ac.ucl.rits.popchat.messages.NewUser;
import uk.ac.ucl.rits.popchat.messages.PasswordChange;
import uk.ac.ucl.rits.popchat.messages.ResultsTableRow;
import uk.ac.ucl.rits.popchat.messages.UserListing;
import uk.ac.ucl.rits.popchat.messages.UserPromotion;
import uk.ac.ucl.rits.popchat.users.PopUser;
import uk.ac.ucl.rits.popchat.users.UserRepository;

/**
 * Manage endpoints that control user accounts.
 *
 * @author RSDG
 *
 */
@RestController
@RequestMapping("/user")
public class UserEndpoints {

    /**
     * User database.
     */
    @Autowired
    private UserRepository             userRepo;
    /**
     * PasswordEncoder for hashing.
     */
    @Autowired
    private PasswordEncoder            passwordEncoder;

    @Autowired
    private SongGameResponseRepository responseRepo;

    private static final Logger        log = LoggerFactory.getLogger(UserEndpoints.class);

    /**
     * Create a new user account. The new user must have a unique username, and will
     * not be an administrator
     *
     * @param user Specification of the new user to create
     */
    @PostMapping("/signup")
    public void signup(@RequestBody NewUser user) {
        PopUser existingUser = userRepo.findByUsername(user.getUsername());
        if (existingUser != null) {
            throw new RuntimeException("Sorry, this username is already taken");
        }
        try {

            PopUser newUser = new PopUser(user.getUsername(), passwordEncoder.encode(user.getPassword()), false);
            userRepo.save(newUser);
        } catch (IllegalStateException e) {
            log.error("Failed to create new user", e);
            throw new RuntimeException("Sorry. New users cannot be created at this time. Please contact support.");
        }
    }

    /**
     * Create a large number of users in a single request.
     *
     * <p>
     * Note that as passwords are generated by this method, it returns them
     * unhashed.
     *
     * @param users The specification of what users to create
     * @return A list of Users (username & password) that have been created.
     */
    @PostMapping("/batch-signup")
    public List<NewUser> batchSignup(@RequestBody BatchUserSpecification users) {
        List<NewUser> generatedUsers = new ArrayList<>();
        Haikunator haik = new Haikunator();
        haik.setTokenLength(1);
        for (int i = 0; i < users.getNumUsers(); i++) {
            // Usernames are numerically sequential
            String username = String.format("%s%d", users.getPrefix(), i + 1);
            // Password are haikunated
            String password = haik.haikunate();
            NewUser generatedUser = new NewUser(username, password);
            this.signup(generatedUser);
            generatedUsers.add(generatedUser);
        }
        return generatedUsers;
    }

    /**
     * Change a user's password.
     *
     * @param passwords The old and new passwords
     * @param principal The user's credentials
     * @return True if the password changed successfully.
     */
    @PostMapping("/change-password")
    public boolean changePassword(Principal principal, @RequestBody PasswordChange passwords) {
        String newPassword = passwords.getNewPassword();
        if (newPassword.isEmpty()) {
            throw new RuntimeException("New password cannot be empty");
        }
        final String username = principal.getName();
        PopUser user = userRepo.findByUsername(username);
        if (user == null) {
            throw new RuntimeException("The current user does not exist");
        }
        if (!this.passwordEncoder.matches(passwords.getOldPassword(), user.getPassword())) {
            throw new RuntimeException("Incorrect current password");
        }
        String newEncodedPassword = this.passwordEncoder.encode(newPassword);
        user.setPassword(newEncodedPassword);
        this.userRepo.save(user);
        return true;
    }

    /**
     * Get all user's and their admin status.
     *
     * @return list of all usernames with their admin status
     */
    @GetMapping("/list")
    public List<UserListing> listAll() {
        List<UserListing> allUsers = new ArrayList<>();
        userRepo.findAll().forEach(user -> {
            allUsers.add(new UserListing(user.getUsername(), user.getIsAdmin()));
        });

        return allUsers;
    }

    /**
     * Promote a user to admin, or remove their admin status. If promote is true it
     * makes them an admin. Otherwise removes it. You cannot change your own status.
     * This is to ensure there is always at least one admin who is able to use the
     * system.
     *
     * @param promote   the user to change.
     * @param principal The user requesting the change
     * @return true if the operation was a success.
     */
    @PostMapping("/promote")
    public boolean makeAdmin(@RequestBody UserPromotion promote, Principal principal) {
        if (promote.getUsername().equals(principal.getName())) {
            throw new RuntimeException("You cannot change your own status");
        }
        final PopUser user = userRepo.findByUsername(promote.getUsername());
        if (user == null) {
            throw new RuntimeException("No such user");
        }
        if (user.getIsAdmin() == promote.isPromote()) {
            return true;
        }
        user.setIsAdmin(promote.isPromote());
        userRepo.save(user);
        return true;
    }

    /**
     * Get all the results.
     *
     * @return A list of Rows to show the results for analysis
     */
    @GetMapping("/results")
    public List<ResultsTableRow> getResult() {
        Iterable<SongGameResponse> responses = responseRepo.findAll();
        List<ResultsTableRow> results = new ArrayList<>();
        for (SongGameResponse r : responses) {
            ResultsTableRow row = new ResultsTableRow();

            // Set user data
            row.setUsername(r.getUser().getUsername());

            // Set answer data
            SongGameQuestionOption selected = r.getQuestionOptionId();
            row.setAnswer(selected.getValue());
            row.setAnswerCorrect(selected.isCorrect());
            row.setAnswerSelectTime(r.getQuestionEndTime());

            // Set question data
            SongGameQuestion q = selected.getParentQuestion();
            row.setQuestionStartTime(r.getQuestionStartTime());
            row.setQuestion(q.getQuestionText());
            row.setAllAnswers(q.getAnswers().stream().map(a -> a.getValue()).collect(Collectors.toList()));

            // Set song data
            row.setSongTitle(q.getParentGame().getSong().getTitle());

            results.add(row);
        }
        return results;
    }
}
